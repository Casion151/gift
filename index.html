<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unlock-by-Quiz Link</title>
  <!-- Tailwind via Play CDN (dev-friendly) -->
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Marked (Markdown -> HTML) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- DOMPurify (sanitize HTML) -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
  <style>
    /* Optional: focus rings for accessibility */
    :focus { outline: 2px solid; outline-offset: 2px; }
  </style>
</head>
<body class="bg-gray-50 min-h-dvh text-gray-900 antialiased">
  <main class="mx-auto max-w-2xl px-4 py-10">
    <header class="mb-6">
      <h1 class="text-3xl font-bold tracking-tight">ğŸ¥®ğŸŒ• Challenge designed by Autumn God</h1>
      <p class="text-gray-600 mt-1">Answer a few magic questions to ğŸª„ the content.</p>
    </header>

    <!-- Progress / Status -->
    <div id="status" class="mb-6 hidden"></div>

    <!-- Quiz Card -->
    <section id="quizCard" class="bg-white rounded-2xl shadow p-5 space-y-6">
      <div class="flex items-center justify-between">
        <h2 class="text-xl font-semibold">Verification</h2>
        <span id="progress" class="text-sm text-gray-500">0 / 0 correct</span>
      </div>

      <form id="quizForm" class="space-y-6"></form>

      <div class="flex items-center gap-3 pt-2">
        <button id="checkBtn" class="px-4 py-2 rounded-2xl bg-gray-900 text-white hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed" type="button">Check answers</button>
        <button id="resetBtn" class="px-3 py-2 rounded-2xl bg-gray-200 text-gray-800 hover:bg-gray-300" type="button">Reset</button>
      </div>
      <p class="text-xs text-gray-500">Note: Your pass is cached on this device for convenience. Use â€œResetâ€ to clear it.</p>
    </section>

    <!-- Content Card (hidden until passed) -->
    <section id="contentCard" class="hidden mt-8 bg-white rounded-2xl shadow overflow-hidden">
      <div class="flex items-center justify-between p-5 border-b">
        <h2 class="text-xl font-semibold">ç»å¯†ï¼æ¡£æ¡ˆè§£é”â€”â€”â€”â€”è¯·ä¸‹è½½mdæ–‡ä»¶è·å–å¹¶æŸ¥çœ‹ï¼Œå…¶ç»è¿‡ç²¾å¿ƒæ’åˆ—ï¼Œæ˜“è¯»</h2>
        <div class="flex gap-2">
          <button id="downloadMdBtn" class="px-3 py-1.5 rounded-xl bg-gray-900 text-white hover:bg-gray-800">Download .md</button>
          <a id="downloadUrlBtn" class="px-3 py-1.5 rounded-xl bg-gray-200 text-gray-800 hover:bg-gray-300 hidden" href="#" download>Download file</a>
        </div>
      </div>
      <article id="renderTarget" class="prose prose-gray px-5 py-6 max-w-none"></article>
    </section>

    <footer class="mt-10 text-xs text-gray-500">
      <p>Template by your fellow engineer. For stronger protection, use a server to verify answers and serve a signed URL.</p>
    </footer>
  </main>

  <script>
    // ======== CONFIGURE HERE ========
    // 1) Put your Markdown content here. You can replace this string or fetch it dynamically.
    const MARKDOWN = `ğŸ§šâ€â™€ï¸dxqğŸ¦‹ç‰¹å…¸ğŸ€\n# å›½å†…ç¯‡\n## 1. çº¿ä¸‹\n### 1.1 è¿‘è·ç¦»çº¿ä¸‹â€”â€”å‘¨æœ«å’Œå¹³æ—¶å¯ä»¥å»å®éªŒå®¤\n1. åœ¨è‡ªå·±æ‰€å¤„çš„å­¦æ ¡å¯»æ‰¾è€å¸ˆï¼ˆæœ€å¯»å¸¸ä¹Ÿæœ€å®¹æ˜“è¿›å…¥è¯¾é¢˜ç»„ï¼‰\n    1. å­¦æ ¡å†…\n    2. å’Œå­¦æ ¡æœ‰åˆä½œå…³ç³»çš„ç§‘ç ”é™¢æ‰€ä¸æœºæ„çš„è¯¾é¢˜ç»„\n2. åœ¨æ‰€å¤„å­¦æ ¡æ‰€åœ¨çš„IPåœ°çš„å…¶ä»–å­¦æ ¡å¯»æ‰¾è¯¾é¢˜ç»„ï¼ˆå› ä¸ºç¦»å¾—è¿‘ï¼Œè€Œä¸”å¯ä»¥å‘¨æœ«å…¨åŠ›çº¿ä¸‹æŠ•å…¥ç§‘ç ”å®ä¹ ï¼‰\n    1. è‡ªå·±é‚®ä»¶è”ç³»ï¼Œæœ€å¥½æœ‰ä¸€å®šçš„ç›¸å…³èƒŒæ™¯ï¼Œæ¯”å¦‚è‡ªå­¦è¿‡ç½‘ä¸Šä¸€äº›çŸ¥åå¤§å­¦çš„å…¬å¼€è¯¾ï¼Œæœ‰è¯¾ç¨‹é¡¹ç›®ï¼Œæˆ–è€…ä¹‹å‰åŠ å…¥è¿‡ç›¸å…³è¯¾é¢˜ç»„ä»¥åŠå‚åŠ è¿‡ç›¸å…³è¯¾é¢˜æ–¹å‘æ¯”è¾ƒåŒ¹é…çš„çŸ¥åç«èµ›\n    2. é€šè¿‡æœ¬æ ¡è€å¸ˆå¸®å¿™ï¼Œè®¤çœŸä¸Šæœ¬æ ¡è€å¸ˆçš„ä¸“ä¸šè¯¾ï¼Œç§¯æä¸å¯¹æ–¹äº¤æµï¼ˆå› ä¸ºè€å¸ˆåªæœ‰ç†Ÿæ‚‰ä½ æ‰ä¼šå¸®ä½ ï¼Œä¸ç„¶å°±æ˜¯æ¯åè‡ªå·±çš„å­¦æœ¯å£°èª‰ï¼‰ã€‚æˆ–è€…å…ˆè¿›æœ¬æ ¡è€å¸ˆè¯¾é¢˜ç»„è¿›è¡Œå®ä¹ å¸®å¿™ã€‚è¯¢é—®æ˜¯å¦æœ‰ç›¸å…³äººè„‰å¸®å¿™æ¨èã€‚\n    3. å‚åŠ å­¦æœ¯ä¼šè®®ï¼Œåœ¨é—´éš™ç§¯æä¸è€å¸ˆäº¤æµï¼ˆä¸è¿‡ä¸€èˆ¬è€å¸ˆæ¯”è¾ƒå¿™ï¼Œéš¾æ‰¾åˆ°æœºä¼šï¼‰ï¼Œä¼šååŠæ—¶å‘é‚®ä»¶ç»™è€å¸ˆä»‹ç»è‡ªå·±ï¼Œè¡¨æ˜è‡ªå·±å¯¹å¯¹æ–¹æ‰€è®²ç ”ç©¶çš„å…´è¶£ã€‚\n### 1.2 è¿œè·ç¦»çº¿ä¸‹â€”â€”æš‘å‡ç§‘ç ”å®ä¹ \n1. ç”³è¯·å„ç§‘ç ”é™¢æ‰€çš„å®˜æ–¹æš‘ç ”é¡¹ç›®(åŒ—å¤§ï¼Œæ¸…åï¼Œä¸­ç§‘å¤§ï¼Œè¥¿æ¹–å¤§å­¦ï¼Œä¸­ç§‘é™¢ï¼ŒåŒ—ç”Ÿæ‰€ç­‰ç­‰éƒ½æœ‰ç›¸å…³çš„é¡¹ç›®)\n    1. å¦‚æœç”³è¯·ä¸ä¸Šï¼Œä¹Ÿå¯ä»¥ç”³è¯·å¯¹åº”çš„æš‘æœŸè¯¾ç¨‹é¡¹ç›®ï¼Œåœ¨è¯¾ç¨‹æœŸé—´å»ç›¸å…³è¯¾é¢˜ç»„è§è¯†ä¸€ä¸‹ã€‚\n2. è‡ªè¡Œè”ç³»ï¼ˆæ³¨æ„è¯¢é—®æ˜¯è‡ªå·±è´Ÿè´£ç”Ÿæ´»è´¹è¿˜æ˜¯å¯¹æ–¹è¡¥è´´ï¼ŒåŒæ—¶è¯¢é—®æ˜¯å¦ä¼šæä¾›æ­£å¼çš„è®¿é—®å­¦ç”ŸIDå¡ï¼‰\n    1. è‡ªå·±é‚®ä»¶è”ç³»ï¼Œæœ€å¥½æœ‰ä¸€å®šçš„ç›¸å…³èƒŒæ™¯ï¼Œæ¯”å¦‚è‡ªå­¦è¿‡ç½‘ä¸Šä¸€äº›çŸ¥åå¤§å­¦çš„å…¬å¼€è¯¾ï¼Œæœ‰è¯¾ç¨‹é¡¹ç›®ï¼Œæˆ–è€…ä¹‹å‰åŠ å…¥è¿‡ç›¸å…³è¯¾é¢˜ç»„ä»¥åŠå‚åŠ è¿‡ç›¸å…³è¯¾é¢˜æ–¹å‘æ¯”è¾ƒåŒ¹é…çš„çŸ¥åç«èµ›\n    2. é€šè¿‡æœ¬æ ¡è€å¸ˆå¸®å¿™ï¼Œè®¤çœŸä¸Šæœ¬æ ¡è€å¸ˆçš„ä¸“ä¸šè¯¾ï¼Œç§¯æä¸å¯¹æ–¹äº¤æµï¼ˆå› ä¸ºè€å¸ˆåªæœ‰ç†Ÿæ‚‰ä½ æ‰ä¼šå¸®ä½ ï¼Œä¸ç„¶å°±æ˜¯æ¯åè‡ªå·±çš„å­¦æœ¯å£°èª‰ï¼‰ã€‚æˆ–è€…å…ˆè¿›æœ¬æ ¡è€å¸ˆè¯¾é¢˜ç»„è¿›è¡Œå®ä¹ å¸®å¿™ã€‚è¯¢é—®æ˜¯å¦æœ‰ç›¸å…³äººè„‰å¸®å¿™æ¨èã€‚\n    3. å‚åŠ å­¦æœ¯ä¼šè®®ï¼Œåœ¨é—´éš™ç§¯æä¸è€å¸ˆäº¤æµï¼ˆä¸è¿‡ä¸€èˆ¬è€å¸ˆæ¯”è¾ƒå¿™ï¼Œéš¾æ‰¾åˆ°æœºä¼šï¼‰ï¼Œä¼šååŠæ—¶å‘é‚®ä»¶ç»™è€å¸ˆä»‹ç»è‡ªå·±ï¼Œè¡¨æ˜è‡ªå·±å¯¹å¯¹æ–¹æ‰€è®²ç ”ç©¶çš„å…´è¶£ã€‚\n## 2. çº¿ä¸Š(å°†ä¸å›½é™…ç¯‡æ”¾åœ¨ä¸€èµ·è®¨è®º)\n\n\n# å›½é™…ç¯‡\n## 1. çº¿ä¸‹ï¼ˆä¸€èˆ¬ä¸å­˜åœ¨è¿œè·ç¦»çº¿ä¸‹ï¼Œå› ä¸ºä¸ç¬¦åˆç­¾è¯è§„å®šï¼Œä¸€èˆ¬åªèƒ½åœ¨æä¾›ç­¾è¯æ”¯æŒçš„å­¦æ ¡è¿›è¡Œçº¿ä¸‹å®ä¹ ï¼‰\n### 1.1 æ—¥å¸¸ç‰ˆçº¿ä¸‹â€”â€”å‘¨æœ«å’Œå¹³æ—¶å¯ä»¥å»å®éªŒå®¤\n1. æŠ¥åè¯¥å­¦æ ¡çš„è®¿é—®äº¤æµé¡¹ç›®\n    1. ä¸€èˆ¬å¦‚æœæ˜¯æ˜¥å­¦æœŸï¼ˆ1æœˆå¼€å§‹ï¼‰çš„è¯ï¼Œéœ€è¦æå‰åˆ°ç§‹å­¦æœŸåˆšå¼€å§‹ï¼ˆ9-10æœˆï¼‰å°±åšäº¤æµé¡¹ç›®çš„æŠ¥åå‡†å¤‡ã€‚ä¹Ÿå°±æ˜¯æå‰ä¸€ä¸ªå­¦æœŸã€‚\n    2. å…·ä½“ææ–™è¦æ±‚æ ¹æ®å­¦æ ¡æœ‰å˜åŒ–ã€‚\n    3. å¯ä»¥æŸ¥çœ‹å¯¹æ¯”ä¸€ä¸‹è‡ªå·±æŠ¥åä¸é€šè¿‡æœ¬ç§‘é™¢æ ¡å¸®åŠ©æŠ¥åçš„ä¸åŒè¦æ±‚ï¼Œæœ‰æ—¶å€™è‡ªå·±æŠ¥åæ‰€éœ€çš„è¦æ±‚ä¼šæ¯”é€šè¿‡æœ¬ç§‘é™¢æ ¡æŠ¥åè¿˜ä½ã€‚è€Œä¸”ä¸€èˆ¬ææ–™äº¤é½æŠ¥åäº†å°±éƒ½ä¼šè¢«å½•å–ï¼ˆæ¯•ç«Ÿå›½å¤–å­¦æ ¡é€šè¿‡å­¦è´¹åˆ›æ”¶ï¼‰ã€‚\n    4. æœ‰äº›é¡¹ç›®æ¥ä¸åŠè€ƒè‹±è¯­æˆç»©çš„è¯ï¼Œå¯ä»¥æäº¤æ‰˜ç¦æˆ–è€…å¤šé‚»å›½ä»£æ›¿ã€‚\n    5. BBSAé¡¹ç›®æ”¶è´¹æ˜¯æœ€ä½çš„ï¼Œå’Œæœ¬åœ°äººä¸€ä¸ªæ ‡å‡†ï¼Œå…¶ä½™åŸºæœ¬éƒ½è¦3ä¸‡ç¾å…ƒä¸€å­¦æœŸï¼Œç›¸åº”çš„åå¤„æ˜¯åœ¨å…¬ç«‹å­¦æ ¡è¿›å®éªŒå®¤æœ‰ç‚¹éº»çƒ¦ã€‚ä¸è¿‡ä¸ªäººä½“éªŒå…¶å®ä¹Ÿä¸æ˜¯ç‰¹åˆ«éº»çƒ¦ï¼Œä¸»è¦åœ¨äºéœ€è¦ç§¯ææ‰¾æ„Ÿå…´è¶£çš„æ•™æˆäº¤æµã€‚åŒæ—¶ï¼Œæˆ‘æœ‰åŒå­¦å»æ¥å“ˆä½›äº¤æ¢ï¼Œå¥¹ä¹Ÿæ‰¾ä¸åˆ°è€å¸ˆæ„¿æ„æ¥å—å¥¹ï¼Œæœ€åæ˜¯é å›½å†…è€å¸ˆï¼ˆåŸæ¥æ˜¯å“ˆä½›çš„åšå£«åï¼‰å¸®å¿™æ¨èå®éªŒå®¤æ‰è¿›å»çš„ã€‚\n6. ä¹‹å‰æåˆ°å‡†å¤‡äº¤æµé¡¹ç›®çš„ç”³è¯·ææ–™ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥å¼€å§‹ç»™æƒ³å»çš„å­¦æ ¡çš„è€å¸ˆå†™é‚®ä»¶è¯¢é—®èƒ½å¦åŠ å…¥å¯¹æ–¹è¯¾é¢˜ç»„äº†ã€‚è¿™æ ·ä½ å¯ä»¥æå‰å’Œå¯¹é¢å®éªŒå®¤å¯¹æ¥ï¼Œä¸€è¿‡å»å°±å¯ä»¥è¿›è¡Œç ”ç©¶ï¼Œè€å¸ˆä¹Ÿä¼šæ›´æ„¿æ„æ¥å—åšè¯¾é¢˜æ—¶é—´é•¿çš„å­¦ç”Ÿã€‚\n    1. è‡ªå·±é‚®ä»¶è”ç³»ï¼Œæœ€å¥½æœ‰ä¸€å®šçš„ç›¸å…³èƒŒæ™¯ï¼Œåšè¿‡ç›¸å…³çš„è¯¾é¢˜é¡¹ç›®ï¼Œæˆ–è€…æŒæ¡ç›¸å…³çš„è¯¾é¢˜ç»„æ‰€éœ€çš„æŠ€èƒ½ã€‚\n    2. é€šè¿‡æŸä¸ªå·²ç»è®¤è¯†ä½ çš„è€å¸ˆå¸®å¿™ï¼Œè®¤çœŸä¸Šæœ¬æ ¡è€å¸ˆçš„ä¸“ä¸šè¯¾ï¼Œæˆ–è€…ç§¯æä¸å¯¹æ–¹äº¤æµè¿‡ï¼ˆå› ä¸ºè€å¸ˆåªæœ‰ç†Ÿæ‚‰ä½ æ‰ä¼šå¸®ä½ ï¼Œä¸ç„¶å°±æ˜¯æ¯åè‡ªå·±çš„å­¦æœ¯å£°èª‰ï¼‰ã€‚æˆ–è€…ä¹‹å‰è¿›è¿‡æŸä¸ªè€å¸ˆè¯¾é¢˜ç»„è¿›è¡Œå®ä¹ å¸®å¿™ã€‚è¯¢é—®æ˜¯å¦æœ‰ç›¸å…³äººè„‰å¸®å¿™æ¨èã€‚\n    3. åœ¨ç”³è¯·å‰å‚åŠ è¿‡å­¦æœ¯ä¼šè®®ï¼Œåœ¨å­¦æœ¯ä¼šè®®ä¸Šä¸è€å¸ˆäº¤æµè¿‡ï¼ˆä¸è¿‡ä¸€èˆ¬è€å¸ˆæ¯”è¾ƒå¿™ï¼Œéš¾æ‰¾åˆ°æœºä¼šï¼‰ï¼Œä¼šåæœ‰è¿‡åŠæ—¶å‘é‚®ä»¶ç»™è€å¸ˆä»‹ç»è‡ªå·±ï¼Œè¡¨æ˜è‡ªå·±å¯¹å¯¹æ–¹æ‰€è®²ç ”ç©¶çš„å…´è¶£ã€‚è¿™æ—¶ï¼Œä½ å†å‘ä¸ªé‚®ä»¶ç»™è€å¸ˆè¯´æˆ‘ä»xxxä¼šè®®ä¸Šå’Œä½ èŠè¿‡ï¼Œç°åœ¨åˆæ¥æ‰¾ä½ äº†ï¼Œè€å¸ˆä¼šæŒºæ„¿æ„æ¥å—ä½ çš„ã€‚\n    4. é€‰æ‹©æƒ³å»çš„å›½å¤–è€å¸ˆä¸Šçš„è¯¾ï¼Œä¸‹è¯¾ä»¥åä¸»åŠ¨è¯¢é—®è€å¸ˆè¿›ç»„æƒ…å†µ\n7. æ³¨æ„ï¼šè¿›è¯¾é¢˜ç»„ä¹‹å‰å¯èƒ½æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š\n    1. æœ‰è€ƒæŸ¥ä¸é¢è¯•ï¼Œæ¯”å¦‚å®Œæˆé¡¹ç›®åšæ±‡æŠ¥å†å†³å®šæ˜¯å¦é•¿æœŸåˆä½œ\n    2. è€å¸ˆç›´æ¥å°†ä½ çš„ä¿¡æ¯æ¨é€ç»™åšå£«åï¼Œä½ è‡ªå·±å’Œåšå£«åå•†é‡é¡¹ç›®\n    3. ä½ ç›´æ¥å’Œè€å¸ˆå¯¹æ¥é¡¹ç›®ï¼ˆæå°‘ï¼Œéœ€è¦çæƒœï¼‰\n### 1.2 è¿‘è·ç¦»çº¿ä¸‹â€”â€”ä¸€ç›´å¾…åœ¨å®éªŒå®¤ï¼ˆç±»ä¼¼åšå£«ç”Ÿçš„ç”Ÿæ´»ï¼Œä¸è¿‡å¯èƒ½æ›´è‹¦ğŸ˜†å› ä¸ºåšå£«ç”Ÿè‡³å°‘è¿˜å¯ä»¥å»å­¦æ ¡ä¸Šè¯¾æ‘¸é±¼ï¼‰\n1. æŠ¥åè¯¥å­¦æ ¡çš„å®˜æ–¹æš‘ç ”é¡¹ç›®ï¼ˆæ—¶é—´2ä¸ªæœˆï¼‰æˆ–è€…ä¸è¯¥å­¦æ ¡çš„è€å¸ˆè‡ªè¡Œè”ç³»æš‘ç ”ï¼ˆæ—¶é—´ä¸º2ä¸ªæœˆï½12ä¸ªæœˆéƒ½æœ‰å¯èƒ½åå•†ï¼‰æ— è®ºæ˜¯å“ªç§ï¼Œéƒ½éœ€è¦æå‰3-6ä¸ªæœˆå’Œè€å¸ˆè”ç³»ã€‚å› ä¸ºéœ€è¦åŠç­¾è¯ï¼Œå¾ˆéº»çƒ¦ï¼\n    1. è‡ªå·±é‚®ä»¶è”ç³»ï¼Œæœ€å¥½æœ‰ä¸€å®šçš„ç›¸å…³èƒŒæ™¯ï¼Œåšè¿‡ç›¸å…³çš„è¯¾é¢˜é¡¹ç›®ï¼Œæˆ–è€…æŒæ¡ç›¸å…³çš„è¯¾é¢˜ç»„æ‰€éœ€çš„æŠ€èƒ½ã€‚\n    2. é€šè¿‡æŸä¸ªå·²ç»è®¤è¯†ä½ çš„è€å¸ˆå¸®å¿™ï¼Œè®¤çœŸä¸Šæœ¬æ ¡è€å¸ˆçš„ä¸“ä¸šè¯¾ï¼Œæˆ–è€…ç§¯æä¸å¯¹æ–¹äº¤æµè¿‡ï¼ˆå› ä¸ºè€å¸ˆåªæœ‰ç†Ÿæ‚‰ä½ æ‰ä¼šå¸®ä½ ï¼Œä¸ç„¶å°±æ˜¯æ¯åè‡ªå·±çš„å­¦æœ¯å£°èª‰ï¼‰ã€‚æˆ–è€…ä¹‹å‰è¿›è¿‡æŸä¸ªè€å¸ˆè¯¾é¢˜ç»„è¿›è¡Œå®ä¹ å¸®å¿™ã€‚è¯¢é—®æ˜¯å¦æœ‰ç›¸å…³äººè„‰å¸®å¿™æ¨èã€‚\n    3. åœ¨ç”³è¯·å‰å‚åŠ è¿‡å­¦æœ¯ä¼šè®®ï¼Œåœ¨çº¿ä¸‹æˆ–è€…çº¿ä¸Šå­¦æœ¯ä¼šè®®ä¸Šä¸è€å¸ˆäº¤æµè¿‡ï¼ˆä¸è¿‡ä¸€èˆ¬è€å¸ˆæ¯”è¾ƒå¿™ï¼Œéš¾æ‰¾åˆ°æœºä¼šï¼‰ï¼Œä¼šåæœ‰è¿‡åŠæ—¶å‘é‚®ä»¶ç»™è€å¸ˆä»‹ç»è‡ªå·±ï¼Œè¡¨æ˜è‡ªå·±å¯¹å¯¹æ–¹æ‰€è®²ç ”ç©¶çš„å…´è¶£ã€‚è¿™æ—¶ï¼Œä½ å†å‘ä¸ªé‚®ä»¶ç»™è€å¸ˆè¯´æˆ‘ä»xxxä¼šè®®ä¸Šå’Œä½ èŠè¿‡ï¼Œç°åœ¨åˆæ¥æ‰¾ä½ äº†ï¼Œè€å¸ˆä¼šæŒºæ„¿æ„æ¥å—ä½ çš„ã€‚\n2. é¦™æ¸¯çš„å­¦æ ¡çš„æš‘ç ”é¡¹ç›®ç›´æ¥ä¸åšå£«å½•å–æŒ‚é’©ã€‚\n\n## 2. çº¿ä¸Šï¼ˆéº»çƒ¦çš„åœ¨äºç›®å‰å¯¹äºæ•°æ®ç®¡æ§æ¯”è¾ƒä¸¥æ ¼ï¼‰\n### 2.1 æ—¥å¸¸ç‰ˆçº¿ä¸Š\n1. å…ˆæŠ¥åä»»æ„å­¦æ ¡çš„äº¤æµé¡¹ç›®ï¼Œå†è”ç³»å…¶ä»–å­¦æ ¡çš„è€å¸ˆè¯¢é—®æ˜¯å¦èƒ½è¿›è¡Œçº¿ä¸Šç§‘ç ”é¡¹ç›®ã€‚æ–¹æ³•åŒä¸Šã€‚\n### 2.2 è‚‰èº«åœ¨å›½å†…çš„çº¿ä¸Š\n1. å¯ä»¥é€šè¿‡æŸ¥é˜…å„å­¦æ ¡ç½‘ç«™æœ‰æ— å¼€æ”¾çš„çº¿ä¸Šé¡¹ç›®ï¼Œæ¯”å¦‚æˆ‘ä»¥å‰å°±æŸ¥åˆ°Stanfordæ˜¯æœ‰ä¸€ä¸ªè¡¨æ ¼ä¸“é—¨åšè¿™ä¸ªäº‹æƒ…çš„ã€‚https://docs.google.com/spreadsheets/d/1yDtCqr36_tMc85M6Usfg877KMoM6lde-E-i6PeW1Ziw/edit?gid=923159611#gid=923159611\n2. è‡ªè¡Œè”ç³» æ–¹æ³•åŒä¸Šã€‚æœ‰äº›è€å¸ˆçš„å®éªŒå®¤å®˜ç½‘ä¸Šä¹Ÿä¼šæœ‰å†™æ‹›å‹Ÿè¿œç¨‹ç§‘ç ”ã€‚ä¸¾ä¸ªğŸŒ°ï¼šhttps://bioinformatics.bwh.harvard.edu/join/\n`;

    // 2) Optional: expose a real download URL after pass (e.g., from Drive/S3).
    // Leave empty string to hide the button.
    const DOWNLOAD_URL_AFTER_PASS = ""; // e.g., "https://example.com/yourfile.pdf"

    // 3) Define your questions. Answers are *hashed* with SHA-256 to avoid plain-text answers in source.
    //    Use window.hashPlain('your answer') in DevTools to generate hashes with the same normalization as checks.
    //    Types: 'text' | 'single' (radio) | 'multiple' (checkbox)
    const QUESTIONS = [
      {
        id: 'q1',
        type: 'text',
        prompt: 'Who is Magic_QiQi?',
        placeholder: 'è¯·å‡†ç¡®æ— è¯¯åœ°è¾“å…¥ä½ çš„åå­—',
        answerHash: '8089263d065ce1db56e3d53f90e56fd556bc8cdb81a7f6606045b9995204393b', // hash of "æˆ´ç­±çª"
        hint: 'ä½ çš„åå­—'
      },
      {
        id: 'q2',
        type: 'single',
        prompt: 'ä¸ºä»€ä¹ˆé€‰æ‹©åœ¨ä»Šå¤©å‘ç»™ä½ ',
        choices: [
          { id: 'a', label: 'æ­£å¥½æ˜¯è®¤è¯†çš„æ»¡å››ä¸ªæœˆ' },
          { id: 'b', label: 'æ­£å·§ä»Šå¤©å¼„å¥½çµæœºä¸€åŠ¨' },
          { id: 'c', label: 'æ­£é€¢ä½³èŠ‚ä¸å½©æ’çš„å‰å¤•' },
          { id: 'd', label: 'å…¶ä»–ï¼Œè¯·å¡«å†™ä½ çš„ç†ç”±', allowCustom: true, customPlaceholder: 'å†™ä¸‹ä½ çš„ç†ç”±å§' }
        ],
        acceptAnySelection: true
      },
      {
        id: 'q3',
        type: 'multiple',
        prompt: 'ä½ ä»Šå¤©å¿«ä¹ğŸŠäº†å—',
        choices: [
          { id: 'a', label: 'ä¸å¿«ä¹ï¼Œå½©æ’å¥½ç´¯' },
          { id: 'b', label: 'ä¸å¿«ä¹ï¼Œæµäº†å¥½å¤šæ±—' },
          { id: 'c', label: 'ä¸å¿«ä¹ï¼Œå¤©æ°”ä¸å¥½' },
          { id: 'd', label: 'ä¸å¿«ä¹ï¼Œé¢†ä¸ªæ–‡ä»¶æ•´è¿™ä¹ˆèŠ±å“¨' },
          { id: 'e', label: 'å…¶ä»–ï¼Œè¯·å¡«å†™ä½ çš„æ„Ÿå—', allowCustom: true, customPlaceholder: 'å†™ä¸‹ä½ çš„æ„Ÿå—å§' },
        ],
        acceptAnySelection: true
      }
    ];

    // 4) Optional: gate by token in URL (e.g., you share /?token=abc123 to one person). If provided,
    //    we store it and require the same token to see the cached pass. Set to false to disable token gating.
    const REQUIRE_URL_TOKEN_TO_REUSE_PASS = true;

    // 5) Optional: push completed responses to a GitHub repo. Fill in these values (token requires repo write access).
    const GITHUB_UPLOAD_CONFIG = {
      owner: '', // e.g., 'your-username'
      repo: '', // e.g., 'your-repo'
      path: 'quiz-responses.json', // file that will store an array of submissions
      branch: 'main',
      commitMessage: 'Add quiz response',
      token: '' // personal access token; set at runtime for security if possible
    };
    // ======== END CONFIG ========

    const el = {
      quizCard: document.getElementById('quizCard'),
      contentCard: document.getElementById('contentCard'),
      quizForm: document.getElementById('quizForm'),
      checkBtn: document.getElementById('checkBtn'),
      resetBtn: document.getElementById('resetBtn'),
      progress: document.getElementById('progress'),
      renderTarget: document.getElementById('renderTarget'),
      status: document.getElementById('status'),
      downloadMdBtn: document.getElementById('downloadMdBtn'),
      downloadUrlBtn: document.getElementById('downloadUrlBtn'),
    };

    // Utilities
    const norm = (str) => str.trim().toLowerCase().replace(/\s+/g, ' ');
    const toHex = (buffer) => Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    async function sha256Hex(input) {
      const data = new TextEncoder().encode(norm(input));
      const hash = await crypto.subtle.digest('SHA-256', data);
      return toHex(hash);
    }

    // Dev helper: quickly generate an answer hash in console.
    window.hashPlain = async (s) => {
      const h = await sha256Hex(String(s));
      console.log(`SHA-256(${JSON.stringify(norm(String(s)))}) =`, h);
      return h;
    };

    // Token handling (optional)
    const url = new URL(location.href);
    const urlToken = url.searchParams.get('token') || '';

    // Local cache key
    const CACHE_KEY = 'quiz-gate-pass-v1';

    function readCache() {
      try {
        return JSON.parse(localStorage.getItem(CACHE_KEY) || '{}');
      } catch { return {}; }
    }
    function writeCache(obj) {
      localStorage.setItem(CACHE_KEY, JSON.stringify(obj));
    }
    function clearCache() {
      localStorage.removeItem(CACHE_KEY);
    }

    // Attempt counters per question
    const attempts = new Map();

    // Render quiz
    function renderQuiz() {
      el.quizForm.innerHTML = '';
      let correctCount = 0;
      attempts.clear();

      QUESTIONS.forEach((q, idx) => {
        const field = document.createElement('fieldset');
        field.className = 'space-y-2';
        field.dataset.qid = q.id;

        const label = document.createElement('legend');
        label.className = 'font-medium flex items-center gap-2';
        label.innerHTML = `<span class="text-gray-800">${idx + 1}. ${q.prompt}</span>`;
        field.appendChild(label);

        const help = document.createElement('div');
        help.className = 'text-sm text-gray-500 hidden';
        help.id = `hint-${q.id}`;
        if (q.hint) help.textContent = q.hint;
        field.appendChild(help);

        const inputWrap = document.createElement('div');
        inputWrap.className = 'mt-1';

        if (q.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = q.placeholder || '';
          input.className = 'w-full rounded-xl border px-3 py-2';
          input.name = q.id;
          inputWrap.appendChild(input);
        }
        else if (q.type === 'single') {
          q.choices.forEach(choice => {
            const id = `${q.id}-${choice.id}`;
            const row = document.createElement('div');
            row.className = 'space-y-2';

            const optionLabel = document.createElement('label');
            optionLabel.className = 'flex items-center gap-3 rounded-xl border px-3 py-2 hover:bg-gray-50';
            optionLabel.setAttribute('for', id);

            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = q.id;
            radio.id = id;
            radio.value = choice.id;
            radio.className = 'size-4';

            const text = document.createElement('span');
            text.textContent = choice.label;

            optionLabel.appendChild(radio);
            optionLabel.appendChild(text);
            row.appendChild(optionLabel);

            if (choice.allowCustom) {
              const customInput = document.createElement('input');
              customInput.type = 'text';
              customInput.placeholder = choice.customPlaceholder || 'è¯·è¾“å…¥ä½ çš„ç­”æ¡ˆ';
              customInput.className = 'ml-7 mt-1 w-full rounded-xl border px-3 py-2 hidden';
              customInput.dataset.customFor = id;
              customInput.disabled = true;
              row.appendChild(customInput);
            }

            inputWrap.appendChild(row);
          });
        }
        else if (q.type === 'multiple') {
          q.choices.forEach(choice => {
            const id = `${q.id}-${choice.id}`;
            const row = document.createElement('div');
            row.className = 'space-y-2';

            const optionLabel = document.createElement('label');
            optionLabel.className = 'flex items-center gap-3 rounded-xl border px-3 py-2 hover:bg-gray-50';
            optionLabel.setAttribute('for', id);

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.name = q.id;
            cb.id = id;
            cb.value = choice.id;
            cb.className = 'size-4';

            const text = document.createElement('span');
            text.textContent = choice.label;

            optionLabel.appendChild(cb);
            optionLabel.appendChild(text);
            row.appendChild(optionLabel);

            if (choice.allowCustom) {
              const customInput = document.createElement('input');
              customInput.type = 'text';
              customInput.placeholder = choice.customPlaceholder || 'è¯·è¾“å…¥ä½ çš„ç­”æ¡ˆ';
              customInput.className = 'ml-7 mt-1 w-full rounded-xl border px-3 py-2 hidden';
              customInput.dataset.customFor = id;
              customInput.disabled = true;
              row.appendChild(customInput);
            }

            inputWrap.appendChild(row);
          });
        }

        const feedback = document.createElement('div');
        feedback.id = `fb-${q.id}`;
        feedback.className = 'text-sm mt-2 h-5';

        field.appendChild(inputWrap);
        field.appendChild(feedback);
        el.quizForm.appendChild(field);

        attempts.set(q.id, 0);
      });

      // progress init
      el.progress.textContent = `0 / ${QUESTIONS.length} correct`;
    }

    function handleChoiceChange(event) {
      const target = event.target;
      if (!target || target.tagName !== 'INPUT') return;
      const fieldset = target.closest('fieldset');
      if (!fieldset) return;

      if (target.type === 'radio') {
        const customInputs = fieldset.querySelectorAll('input[data-custom-for]');
        customInputs.forEach(input => {
          const match = input.dataset.customFor === target.id;
          input.classList.toggle('hidden', !match);
          input.disabled = !match;
          if (!match) input.value = '';
          if (match) input.focus();
        });
      } else if (target.type === 'checkbox') {
        const customInput = fieldset.querySelector(`input[data-custom-for="${target.id}"]`);
        if (customInput) {
          const show = target.checked;
          customInput.classList.toggle('hidden', !show);
          customInput.disabled = !show;
          if (!show) customInput.value = '';
          else customInput.focus();
        }
      }
    }

    // Collect and check answers
    async function checkAnswers() {
      let correctCount = 0;
      const attemptAnswers = {};

      for (const q of QUESTIONS) {
        const feedback = document.getElementById(`fb-${q.id}`);
        const hintEl = document.getElementById(`hint-${q.id}`);
        let ok = false;
        let failReason = null;

        if (q.type === 'text') {
          const input = el.quizForm.querySelector(`input[name="${q.id}"]`);
          const val = input.value;
          attemptAnswers[q.id] = { type: 'text', value: val };
          if (!val.trim()) failReason = 'empty';
          const h = await sha256Hex(val);
          ok = (h === q.answerHash);
        }
        else if (q.type === 'single') {
          const sel = el.quizForm.querySelector(`input[name="${q.id}"]:checked`);
          const selected = sel ? sel.value : '';
          const selectedChoice = selected ? q.choices.find(choice => choice.id === selected) || null : null;
          const customInput = sel ? el.quizForm.querySelector(`input[data-custom-for="${sel.id}"]`) : null;
          const customValue = customInput ? customInput.value.trim() : '';

          attemptAnswers[q.id] = {
            type: 'single',
            selectedOption: selected || null,
            selectedLabel: selectedChoice ? selectedChoice.label : null,
            customText: customValue || null
          };

          if (q.acceptAnySelection) {
            if (selectedChoice && selectedChoice.allowCustom) {
              ok = customValue.length > 0;
              if (!ok) failReason = 'custom-empty';
            } else if (selected) {
              ok = true;
            } else {
              failReason = 'no-selection';
            }
          } else if (selected && q.correctOptionsHash) {
            const h = await sha256Hex(selected);
            ok = (h === q.correctOptionsHash);
            if (!ok) failReason = 'mismatch';
          } else if (!selected) {
            failReason = 'no-selection';
          }
        }
        else if (q.type === 'multiple') {
          const selectedOptions = Array.from(el.quizForm.querySelectorAll(`input[name="${q.id}"]:checked`)).map(el => el.value).sort();
          const selected = selectedOptions.join('|');
          const customTexts = {};
          let customMissing = false;
          attemptAnswers[q.id] = {
            type: 'multiple',
            selectedOptions,
            selectedLabels: selectedOptions.map(val => {
              const match = q.choices.find(choice => choice.id === val);
              return match ? match.label : val;
            }),
            customTexts: null
          };
          selectedOptions.forEach(val => {
            const choice = q.choices.find(choice => choice.id === val);
            if (choice && choice.allowCustom) {
              const input = el.quizForm.querySelector(`input[data-custom-for="${q.id}-${choice.id}"]`);
              const text = input ? input.value.trim() : '';
              customTexts[val] = text;
              if (!text) {
                customMissing = true;
                failReason = 'custom-empty';
              }
            }
          });
          if (Object.keys(customTexts).length) {
            attemptAnswers[q.id].customTexts = customTexts;
          }
          if (!selectedOptions.length) failReason = failReason || 'no-selection';

          if (q.acceptAnySelection) {
            if (selectedOptions.length && !customMissing) {
              ok = true;
            } else {
              ok = false;
              if (!selectedOptions.length && !failReason) failReason = 'no-selection';
              if (customMissing) failReason = 'custom-empty';
            }
          } else if (q.correctOptionsHash) {
            const h = await sha256Hex(selected);
            ok = (h === q.correctOptionsHash);
            if (!ok && !failReason) failReason = 'mismatch';
            if (ok && customMissing) {
              ok = false;
              failReason = 'custom-empty';
            }
          }
        }

        if (ok) {
          correctCount++;
          feedback.textContent = 'âœ”ï¸ Correct';
          feedback.className = 'text-sm mt-2 text-emerald-700';
        } else {
          const count = attempts.get(q.id) + 1;
          attempts.set(q.id, count);
          let failMessage = 'âŒ Try again';
          if (failReason === 'no-selection') failMessage = 'âŒ è¯·é€‰æ‹©ä¸€ä¸ªé€‰é¡¹';
          else if (failReason === 'custom-empty') failMessage = 'âŒ è¯·å¡«å†™ä½ çš„ç†ç”±';
          else if (failReason === 'empty') failMessage = 'âŒ è¯·å¡«å†™ç­”æ¡ˆ';
          feedback.textContent = failMessage;
          feedback.className = 'text-sm mt-2 text-rose-700';
          if (count >= 2 && hintEl && hintEl.textContent) hintEl.classList.remove('hidden');
        }
      }

      el.progress.textContent = `${correctCount} / ${QUESTIONS.length} correct`;

      if (correctCount === QUESTIONS.length) await onPassed(attemptAnswers);
    }

    // After pass
    async function onPassed(answers) {
      // Cache pass with timestamp and token (if required)
      const payload = { passedAt: Date.now(), token: urlToken || null };
      writeCache(payload);

      let statusMessage = 'Access granted';
      let statusKind = 'success';

      if (answers) {
        const submission = {
          timestamp: new Date().toISOString(),
          token: urlToken || null,
          answers
        };

        try {
          const result = await uploadResponseToGithub(submission);
          if (result === 'saved') {
            statusMessage = 'Access granted. Response saved to GitHub.';
          } else if (result === 'skipped') {
            statusMessage = 'Access granted. Response not saved (GitHub upload disabled).';
            statusKind = 'warn';
          }
        } catch (error) {
          console.error('GitHub upload failed:', error);
          statusMessage = 'Access granted. Response could not be saved to GitHub.';
          statusKind = 'warn';
        }
      }

      showStatus(statusMessage, statusKind);
      revealContent();
    }

    function showStatus(msg, kind = 'info') {
      el.status.classList.remove('hidden');
      el.status.className = 'mb-6 p-3 rounded-xl ' + (kind === 'success' ? 'bg-emerald-50 text-emerald-800' : kind === 'warn' ? 'bg-amber-50 text-amber-800' : 'bg-gray-100 text-gray-800');
      el.status.textContent = msg;
    }

    function revealContent() {
      // Render Markdown -> HTML and sanitize
      const rawHtml = marked.parse(MARKDOWN);
      const safeHtml = DOMPurify.sanitize(rawHtml);
      el.renderTarget.innerHTML = safeHtml;

      // Toggle cards
      el.quizCard.classList.add('hidden');
      el.contentCard.classList.remove('hidden');

      // Download buttons
      el.downloadMdBtn.onclick = (e) => {
        e.preventDefault();
        const blob = new Blob([MARKDOWN], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'content.md';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      };

      if (DOWNLOAD_URL_AFTER_PASS) {
        el.downloadUrlBtn.classList.remove('hidden');
        el.downloadUrlBtn.href = DOWNLOAD_URL_AFTER_PASS;
      }
    }

    async function uploadResponseToGithub(submission) {
      const { owner, repo, path, branch, commitMessage, token } = GITHUB_UPLOAD_CONFIG;
      if (!owner || !repo || !path || !token) {
        console.warn('GitHub upload skipped: missing owner, repo, path, or token.');
        return 'skipped';
      }

      const targetBranch = branch || 'main';
      const headers = {
        'Accept': 'application/vnd.github+json',
        'Authorization': `Bearer ${token}`,
        'X-GitHub-Api-Version': '2022-11-28'
      };
      const safeOwner = encodeURIComponent(owner);
      const safeRepo = encodeURIComponent(repo);
      const encodedPath = path.split('/').map(segment => encodeURIComponent(segment)).join('/');
      const apiUrl = `https://api.github.com/repos/${safeOwner}/${safeRepo}/contents/${encodedPath}`;

      let existingSha;
      let entries = [];
      try {
        const res = await fetch(`${apiUrl}?ref=${encodeURIComponent(targetBranch)}`, { headers });
        if (res.status === 200) {
          const data = await res.json();
          existingSha = data.sha;
          const raw = data.content.replace(/\n/g, '');
          const bytes = Uint8Array.from(atob(raw), c => c.charCodeAt(0));
          const decoded = new TextDecoder().decode(bytes);
          const parsed = JSON.parse(decoded || '[]');
          if (Array.isArray(parsed)) entries = parsed;
          else if (parsed && typeof parsed === 'object') entries = [parsed];
        } else if (res.status !== 404) {
          throw new Error(`GitHub read failed with status ${res.status}`);
        }
      } catch (error) {
        throw error;
      }

      entries.push(submission);

      const jsonText = JSON.stringify(entries, null, 2);
      const encodedBytes = new TextEncoder().encode(jsonText);
      const base64Content = btoa(Array.from(encodedBytes, byte => String.fromCharCode(byte)).join(''));

      const body = {
        message: commitMessage || 'Add quiz response',
        content: base64Content,
        branch: targetBranch
      };
      if (existingSha) body.sha = existingSha;

      const saveRes = await fetch(apiUrl, {
        method: 'PUT',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      if (!saveRes.ok) {
        throw new Error(`GitHub write failed with status ${saveRes.status}`);
      }

      return 'saved';
    }

    function resetAll() {
      clearCache();
      el.quizCard.classList.remove('hidden');
      el.contentCard.classList.add('hidden');
      renderQuiz();
      showStatus('Reset complete. Answers cleared on this device.', 'info');
    }

    // Try resume from cache
    function tryResume() {
      const cache = readCache();
      const hasPass = !!cache.passedAt;
      if (!hasPass) return false;
      if (REQUIRE_URL_TOKEN_TO_REUSE_PASS && cache.token !== (urlToken || null)) {
        showStatus('This link has a different token than the one used when you passed. Please answer again.', 'warn');
        return false;
      }
      showStatus('Pass recognized on this device.', 'success');
      revealContent();
      return true;
    }

    // Wire up
    el.quizForm.addEventListener('change', handleChoiceChange);
    el.checkBtn.addEventListener('click', checkAnswers);
    el.resetBtn.addEventListener('click', resetAll);

    // Init
    (function init() {
      renderQuiz();
      tryResume();
    })();
  </script>
</body>
</html>
